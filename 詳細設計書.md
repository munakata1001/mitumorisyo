# 見積書デモアプリ 詳細設計書

## 1. ドキュメント情報

### 1.1 ドキュメント情報
- **ドキュメント名**: 詳細設計書
- **バージョン**: 1.0
- **作成日**: YYYY-MM-DD
- **作成者**: -
- **関連ドキュメント**: 要件定義書、基本設計書

### 1.2 改訂履歴

| 版 | 日付 | 改訂内容 | 改訂者 |
|---|------|---------|--------|
| 1.0 | YYYY-MM-DD | 初版作成 | - |

---

## 2. コンポーネント詳細設計

### 2.1 共通コンポーネント

#### 2.1.1 Button コンポーネント

**ファイル**: `components/common/Button.tsx`

**Props定義**:
```typescript
interface ButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  variant?: 'primary' | 'secondary' | 'danger' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  type?: 'button' | 'submit' | 'reset';
  icon?: React.ReactNode;
  iconPosition?: 'left' | 'right';
  fullWidth?: boolean;
  className?: string;
}
```

**実装詳細**:
- **スタイル**: Tailwind CSSを使用
- **バリアント別スタイル**:
  - `primary`: 青色背景、白色テキスト
  - `secondary`: グレー背景、黒色テキスト
  - `danger`: 赤色背景、白色テキスト
  - `outline`: 透明背景、青色ボーダー
- **サイズ別スタイル**:
  - `sm`: 高さ32px、パディング8px 12px、フォントサイズ12px
  - `md`: 高さ40px、パディング10px 16px、フォントサイズ14px
  - `lg`: 高さ48px、パディング12px 20px、フォントサイズ16px
- **無効状態**: `disabled`時はグレーアウト、カーソル`not-allowed`
- **ホバー効果**: `transition-colors`で色変化
- **フォーカス**: アウトライン表示（アクセシビリティ対応）

**使用例**:
```typescript
<Button 
  variant="primary" 
  size="md" 
  onClick={handleClick}
  icon={<SaveIcon />}
  iconPosition="left"
>
  保存
</Button>
```

---

#### 2.1.2 Input コンポーネント

**ファイル**: `components/common/Input.tsx`

**Props定義**:
```typescript
interface InputProps {
  label?: string;
  name: string;
  type?: 'text' | 'number' | 'email' | 'password' | 'date';
  value: string | number;
  onChange: (value: string | number) => void;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  error?: string;
  helperText?: string;
  prefix?: React.ReactNode;
  suffix?: string; // 単位表示用
  min?: number;
  max?: number;
  step?: number;
  formatNumber?: boolean; // 数値のカンマ区切り表示
  className?: string;
}
```

**実装詳細**:
- **数値フォーマット**: `formatNumber=true`時、カンマ区切り表示
- **バリデーション**: `error`プロップでエラー表示
- **必須マーク**: `required=true`時、ラベルに「*」表示
- **単位表示**: `suffix`で単位（円、kg等）を表示
- **プレフィックス**: アイコン等を表示可能

**実装コード例**:
```typescript
const Input: React.FC<InputProps> = ({
  label,
  name,
  type = 'text',
  value,
  onChange,
  placeholder,
  required,
  disabled,
  error,
  helperText,
  suffix,
  formatNumber,
  ...props
}) => {
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = type === 'number' 
      ? parseFloat(e.target.value) || 0
      : e.target.value;
    onChange(newValue);
  };

  const displayValue = formatNumber && typeof value === 'number'
    ? value.toLocaleString('ja-JP')
    : value;

  return (
    <div className="w-full">
      {label && (
        <label className="block text-sm font-medium text-gray-700 mb-1">
          {label}
          {required && <span className="text-red-500 ml-1">*</span>}
        </label>
      )}
      <div className="relative">
        <input
          type={type}
          name={name}
          value={displayValue}
          onChange={handleChange}
          placeholder={placeholder}
          disabled={disabled}
          className={`
            w-full px-3 py-2 border rounded-md
            ${error ? 'border-red-500' : 'border-gray-300'}
            ${disabled ? 'bg-gray-100 cursor-not-allowed' : 'bg-white'}
            focus:outline-none focus:ring-2 focus:ring-blue-500
          `}
          {...props}
        />
        {suffix && (
          <span className="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500">
            {suffix}
          </span>
        )}
      </div>
      {error && (
        <p className="mt-1 text-sm text-red-500">{error}</p>
      )}
      {helperText && !error && (
        <p className="mt-1 text-sm text-gray-500">{helperText}</p>
      )}
    </div>
  );
};
```

---

#### 2.1.3 Select コンポーネント

**ファイル**: `components/common/Select.tsx`

**Props定義**:
```typescript
interface SelectProps {
  label?: string;
  name: string;
  value: string;
  onChange: (value: string) => void;
  options: Array<{ value: string; label: string }>;
  placeholder?: string;
  required?: boolean;
  disabled?: boolean;
  error?: string;
  className?: string;
}
```

**実装詳細**:
- **カスタムセレクト**: デフォルトの`<select>`を使用
- **スタイル**: Tailwind CSSでスタイリング
- **エラー表示**: `error`プロップでエラーメッセージ表示

---

#### 2.1.4 DatePicker コンポーネント

**ファイル**: `components/common/DatePicker.tsx`

**Props定義**:
```typescript
interface DatePickerProps {
  label?: string;
  name: string;
  value: Date | null;
  onChange: (date: Date | null) => void;
  minDate?: Date;
  maxDate?: Date;
  required?: boolean;
  disabled?: boolean;
  error?: string;
  className?: string;
}
```

**実装詳細**:
- **日付入力**: HTML5の`<input type="date">`を使用
- **日付フォーマット**: `YYYY-MM-DD`形式
- **日付制限**: `minDate`、`maxDate`で制限可能

---

### 2.2 見積書関連コンポーネント

#### 2.2.1 ProjectInfoForm コンポーネント

**ファイル**: `components/estimate/ProjectInfoForm.tsx`

**Props定義**:
```typescript
interface ProjectInfoFormProps {
  projectInfo: ProjectInfo;
  onChange: (info: ProjectInfo) => void;
  errors?: Partial<Record<keyof ProjectInfo, string>>;
}
```

**実装詳細**:

**状態管理**:
- Propsで`projectInfo`を受け取り、変更時に`onChange`を呼び出す
- 各入力フィールドでリアルタイムバリデーション

**レイアウト**:
```typescript
// グリッドレイアウト（3列）
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
  {/* 各入力フィールド */}
</div>
```

**入力フィールド実装**:
- **見積番号**: `Input`コンポーネント（type="text"）
- **客先**: `Input`コンポーネント（type="text"）
- **向先**: `Input`コンポーネント（type="text"）
- **機器名**: `Input`コンポーネント（type="text"）
- **製作数量**: `Input`コンポーネント（type="number"）+ 単位選択（ラジオボタン）
- **納期**: `DatePicker`コンポーネント
- **機種**: `Select`コンポーネント（機種リストから選択）
- **機器形状**: `Input`コンポーネント（type="text"）
- **重量**: `Input`コンポーネント（type="number", suffix="kg"）

**バリデーション**:
```typescript
const validateField = (field: keyof ProjectInfo, value: any): string | undefined => {
  switch (field) {
    case 'estimateNumber':
      if (!value || value.trim() === '') {
        return '見積番号は必須です';
      }
      break;
    case 'productionQuantity':
      if (!value || value <= 0) {
        return '製作数量は0より大きい値が必要です';
      }
      break;
    // その他のバリデーション
  }
  return undefined;
};
```

**イベントハンドラ**:
```typescript
const handleFieldChange = (field: keyof ProjectInfo, value: any) => {
  const error = validateField(field, value);
  const newInfo = { ...projectInfo, [field]: value };
  onChange(newInfo);
  
  // エラーを親コンポーネントに通知
  if (onError) {
    onError({ ...errors, [field]: error });
  }
};
```

---

#### 2.2.2 FileUpload コンポーネント

**ファイル**: `components/estimate/FileUpload.tsx`

**Props定義**:
```typescript
interface FileUploadProps {
  onUpload: (files: File[], mode: string) => Promise<void>;
  maxSize?: number; // デフォルト: 10MB
  acceptedTypes?: string[]; // デフォルト: ['.xlsx', '.xlsm', '.xls', '.pdf']
  maxFiles?: number; // デフォルト: 3
}
```

**実装詳細**:

**状態管理**:
```typescript
const [files, setFiles] = useState<File[]>([]);
const [mode, setMode] = useState<string>('個別解析');
const [isDragging, setIsDragging] = useState(false);
const [isProcessing, setIsProcessing] = useState(false);
const [message, setMessage] = useState<{ type: string; text: string } | null>(null);
```

**ドラッグ&ドロップ実装**:
```typescript
const handleDragOver = (e: React.DragEvent) => {
  e.preventDefault();
  setIsDragging(true);
};

const handleDragLeave = (e: React.DragEvent) => {
  e.preventDefault();
  setIsDragging(false);
};

const handleDrop = (e: React.DragEvent) => {
  e.preventDefault();
  setIsDragging(false);
  
  const droppedFiles = Array.from(e.dataTransfer.files);
  handleFiles(droppedFiles);
};

const handleFiles = async (newFiles: File[]) => {
  // ファイル検証
  const validatedFiles = validateFiles(newFiles);
  if (validatedFiles.length === 0) return;
  
  setFiles(prev => [...prev, ...validatedFiles]);
};
```

**ファイル検証**:
```typescript
const validateFiles = (files: File[]): File[] => {
  const validFiles: File[] = [];
  
  files.forEach(file => {
    // ファイル形式チェック
    const isValidType = acceptedTypes.some(type => 
      file.name.toLowerCase().endsWith(type.toLowerCase())
    );
    
    if (!isValidType) {
      setMessage({ type: 'error', text: `${file.name}: 対応していないファイル形式です` });
      return;
    }
    
    // ファイルサイズチェック
    if (file.size > maxSize) {
      setMessage({ type: 'error', text: `${file.name}: ファイルサイズが大きすぎます（最大${maxSize / 1024 / 1024}MB）` });
      return;
    }
    
    validFiles.push(file);
  });
  
  return validFiles;
};
```

**解析処理**:
```typescript
const handleParse = async () => {
  if (files.length === 0) {
    setMessage({ type: 'error', text: 'ファイルを選択してください' });
    return;
  }
  
  setIsProcessing(true);
  setMessage(null);
  
  try {
    await onUpload(files, mode);
    setMessage({ type: 'success', text: 'ファイルの解析が完了しました' });
    setFiles([]); // 解析後はファイルをクリア
  } catch (error) {
    setMessage({ type: 'error', text: error.message || 'ファイルの解析に失敗しました' });
  } finally {
    setIsProcessing(false);
  }
};
```

**UI実装**:
```typescript
return (
  <div className="space-y-4">
    {/* ドラッグ&ドロップエリア */}
    <div
      className={`
        border-2 border-dashed rounded-lg p-8 text-center
        ${isDragging ? 'border-blue-500 bg-blue-50' : 'border-gray-300 bg-gray-50'}
        transition-colors
      `}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <input
        type="file"
        multiple
        accept={acceptedTypes.join(',')}
        onChange={(e) => handleFiles(Array.from(e.target.files || []))}
        className="hidden"
        id="file-input"
      />
      <label htmlFor="file-input" className="cursor-pointer">
        <p className="text-gray-600">ファイルをドラッグ&ドロップ</p>
        <p className="text-sm text-gray-500 mt-2">または</p>
        <Button variant="outline" className="mt-2">
          ファイルを選択
        </Button>
      </label>
      <p className="text-xs text-gray-400 mt-2">
        対応形式: {acceptedTypes.join(', ')} | 最大{maxSize / 1024 / 1024}MB
      </p>
    </div>
    
    {/* 解析モード選択 */}
    <div>
      <label className="block text-sm font-medium mb-2">解析モード</label>
      <div className="flex gap-4">
        {['個別解析', '2ファイル統合', '3ファイル統合', '2ファイル+価格参考'].map(m => (
          <label key={m} className="flex items-center">
            <input
              type="radio"
              value={m}
              checked={mode === m}
              onChange={(e) => setMode(e.target.value)}
              className="mr-2"
            />
            {m}
          </label>
        ))}
      </div>
    </div>
    
    {/* ファイル一覧 */}
    {files.length > 0 && (
      <div className="space-y-2">
        {files.map((file, index) => (
          <div key={index} className="flex items-center justify-between p-2 bg-gray-50 rounded">
            <span className="text-sm">{file.name}</span>
            <span className="text-xs text-gray-500">
              {(file.size / 1024 / 1024).toFixed(2)}MB
            </span>
            <button
              onClick={() => setFiles(files.filter((_, i) => i !== index))}
              className="text-red-500 hover:text-red-700"
            >
              ×
            </button>
          </div>
        ))}
      </div>
    )}
    
    {/* 解析ボタン */}
    <Button
      variant="primary"
      onClick={handleParse}
      disabled={files.length === 0 || isProcessing}
    >
      {isProcessing ? '解析中...' : '解析開始'}
    </Button>
    
    {/* メッセージ表示 */}
    {message && (
      <div className={`
        p-3 rounded
        ${message.type === 'success' ? 'bg-green-50 text-green-700' : ''}
        ${message.type === 'error' ? 'bg-red-50 text-red-700' : ''}
        ${message.type === 'info' ? 'bg-blue-50 text-blue-700' : ''}
      `}>
        {message.text}
      </div>
    )}
  </div>
);
```

---

#### 2.2.3 EstimateTable コンポーネント

**ファイル**: `components/estimate/EstimateTable.tsx`

**Props定義**:
```typescript
interface EstimateTableProps {
  data: EstimateTableRow[];
  onAdd: () => void;
  onRemove: (id: string) => void;
  onUpdate: (id: string, data: Partial<EstimateTableRow>) => void;
  onRecalculate?: () => void;
}
```

**実装詳細**:

**テーブル構造**:
```typescript
<table className="w-full border-collapse">
  <thead>
    <tr className="bg-gray-100">
      <th className="border p-2 text-left">型式</th>
      <th className="border p-2 text-left">名称</th>
      <th className="border p-2 text-left">Part Type</th>
      <th className="border p-2 text-left">材質</th>
      <th className="border p-2 text-left">寸法入力</th>
      <th className="border p-2 text-left">数量</th>
      <th className="border p-2 text-left">重量</th>
      <th className="border p-2 text-left">単価</th>
      <th className="border p-2 text-left">価格</th>
      <th className="border p-2 text-left">自動</th>
      <th className="border p-2 text-left">操作</th>
    </tr>
  </thead>
  <tbody>
    {data.map((row) => (
      <TableRow
        key={row.id}
        row={row}
        onUpdate={onUpdate}
        onRemove={onRemove}
      />
    ))}
  </tbody>
  <tfoot>
    <tr>
      <td colSpan={8} className="border p-2 text-right font-bold">
        合計
      </td>
      <td className="border p-2 font-bold">
        {data.reduce((sum, row) => sum + row.price, 0).toLocaleString('ja-JP')}円
      </td>
    </tr>
  </tfoot>
</table>
```

**TableRow コンポーネント**:
```typescript
const TableRow: React.FC<{
  row: EstimateTableRow;
  onUpdate: (id: string, data: Partial<EstimateTableRow>) => void;
  onRemove: (id: string) => void;
}> = ({ row, onUpdate, onRemove }) => {
  const handleCellChange = (field: keyof EstimateTableRow, value: any) => {
    onUpdate(row.id, { [field]: value });
    
    // 価格の自動計算
    if (field === 'unitPrice' || field === 'quantity' || field === 'weight') {
      const newPrice = calculatePrice(row, field, value);
      onUpdate(row.id, { price: newPrice });
    }
  };
  
  return (
    <tr className={`
      ${row.isAutoInput ? 'bg-yellow-50' : ''}
      ${row.isTemplateDiff ? 'bg-blue-50' : ''}
    `}>
      <td className="border p-2">
        <input
          type="text"
          value={row.modelNumber}
          onChange={(e) => handleCellChange('modelNumber', e.target.value)}
          className="w-full px-2 py-1 border rounded"
        />
      </td>
      {/* その他のセル */}
      <td className="border p-2">
        <button
          onClick={() => onRemove(row.id)}
          className="text-red-500 hover:text-red-700"
        >
          削除
        </button>
      </td>
    </tr>
  );
};
```

**価格計算ロジック**:
```typescript
const calculatePrice = (
  row: EstimateTableRow,
  changedField: string,
  newValue: any
): number => {
  let unitPrice = row.unitPrice;
  let quantity = row.quantity;
  let weight = row.weight;
  
  if (changedField === 'unitPrice') {
    unitPrice = newValue;
  } else if (changedField === 'quantity') {
    quantity = newValue;
  } else if (changedField === 'weight') {
    weight = newValue;
  }
  
  // 重量ベースの計算（isAuto=trueの場合）
  if (row.isAuto && weight > 0) {
    return unitPrice * weight;
  }
  
  // 通常の計算
  return unitPrice * quantity;
};
```

---

#### 2.2.4 DimensionInput コンポーネント

**ファイル**: `components/estimate/DimensionInput.tsx`

**Props定義**:
```typescript
interface DimensionInputProps {
  partType: string;
  value: DimensionData;
  onChange: (data: DimensionData) => void;
}
```

**実装詳細**:

**Part Type別の入力フォーム**:
```typescript
const DimensionInput: React.FC<DimensionInputProps> = ({ partType, value, onChange }) => {
  const handleChange = (field: string, val: number | string) => {
    onChange({
      ...value,
      partType,
      [field]: val
    });
  };
  
  // Part Type別のレンダリング
  switch (partType) {
    case '板金':
      return (
        <div className="grid grid-cols-4 gap-2">
          <Input
            label="長さ"
            type="number"
            value={value.length || 0}
            onChange={(val) => handleChange('length', val)}
            suffix="mm"
          />
          <Input
            label="幅"
            type="number"
            value={value.width || 0}
            onChange={(val) => handleChange('width', val)}
            suffix="mm"
          />
          <Input
            label="厚さ"
            type="number"
            value={value.thickness || 0}
            onChange={(val) => handleChange('thickness', val)}
            suffix="mm"
          />
        </div>
      );
    
    case '円筒':
      return (
        <div className="grid grid-cols-2 gap-2">
          <Input
            label="直径"
            type="number"
            value={value.diameter || 0}
            onChange={(val) => handleChange('diameter', val)}
            suffix="mm"
          />
          <Input
            label="高さ"
            type="number"
            value={value.height || 0}
            onChange={(val) => handleChange('height', val)}
            suffix="mm"
          />
        </div>
      );
    
    default:
      return (
        <Input
          label="寸法"
          type="text"
          value={value.custom || ''}
          onChange={(val) => handleChange('custom', val)}
          placeholder="寸法を入力"
        />
      );
  }
};
```

---

#### 2.2.5 CostCalculationForm コンポーネント

**ファイル**: `components/estimate/CostCalculationForm.tsx`

**Props定義**:
```typescript
interface CostCalculationFormProps {
  costCalculation: CostCalculation;
  onChange: (calc: CostCalculation) => void;
  tableData: EstimateTableRow[];
}
```

**実装詳細**:

**自動計算項目の表示**:
```typescript
const CostCalculationForm: React.FC<CostCalculationFormProps> = ({
  costCalculation,
  onChange,
  tableData
}) => {
  // 材料費の自動計算
  const materialCost = useMemo(() => {
    return calculateMaterialCost(tableData);
  }, [tableData]);
  
  // 加工費の自動計算
  const processingCost = useMemo(() => {
    return calculateProcessingCost(tableData);
  }, [tableData]);
  
  // 塗装費の自動計算
  const paintingCost = useMemo(() => {
    return calculatePaintingCost(costCalculation.paintingArea);
  }, [costCalculation.paintingArea]);
  
  // 原価サマリーの自動計算
  const costSummary = useMemo(() => {
    return calculateCostSummary({
      ...costCalculation,
      materialCost,
      processingCost,
      paintingCost
    });
  }, [costCalculation, materialCost, processingCost, paintingCost]);
  
  return (
    <div className="space-y-6">
      {/* 自動計算項目 */}
      <section className="bg-gray-50 p-4 rounded">
        <h3 className="font-bold mb-4">自動計算項目</h3>
        <div className="grid grid-cols-2 gap-4">
          <Input
            label="材料費"
            type="number"
            value={materialCost}
            disabled
            suffix="円"
            formatNumber
          />
          <Input
            label="加工費"
            type="number"
            value={processingCost}
            disabled
            suffix="円"
            formatNumber
          />
          <Input
            label="塗装費"
            type="number"
            value={paintingCost}
            disabled
            suffix="円"
            formatNumber
          />
          <Input
            label="塗装面積"
            type="number"
            value={costCalculation.paintingArea}
            disabled
            suffix="m²"
          />
        </div>
      </section>
      
      {/* 手動入力項目 */}
      <section>
        <h3 className="font-bold mb-4">手動入力項目</h3>
        <div className="grid grid-cols-2 gap-4">
          <Input
            label="外注検査費"
            type="number"
            value={costCalculation.externalInspectionCost}
            onChange={(val) => onChange({ ...costCalculation, externalInspectionCost: val })}
            required
            suffix="円"
            formatNumber
          />
          {/* その他の手動入力項目 */}
        </div>
      </section>
      
      {/* 原価サマリー */}
      <section className="bg-blue-50 p-4 rounded">
        <h3 className="font-bold mb-4">原価サマリー</h3>
        <div className="space-y-2">
          <div className="flex justify-between">
            <span>直接原価:</span>
            <span className="font-bold">{costSummary.directCost.toLocaleString('ja-JP')}円</span>
          </div>
          <div className="flex justify-between">
            <span>製造原価:</span>
            <span className="font-bold">{costSummary.manufacturingCost.toLocaleString('ja-JP')}円</span>
          </div>
          <div className="flex justify-between text-xl">
            <span>総原価:</span>
            <span className="font-bold text-blue-600">
              {costSummary.totalCost.toLocaleString('ja-JP')}円
            </span>
          </div>
        </div>
      </section>
    </div>
  );
};
```

---

### 2.3 状態管理ストア

#### 2.3.1 estimateStore（Zustand）

**ファイル**: `store/estimateStore.ts`

**実装詳細**:
```typescript
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import type { ProjectInfo, EstimateTableRow, CostCalculation, RemarksData, ApprovalInfo } from '@/types/estimate';

interface EstimateStore {
  // 状態
  projectInfo: ProjectInfo;
  tableData: EstimateTableRow[];
  costCalculation: CostCalculation;
  remarksData: RemarksData;
  approvalInfo: ApprovalInfo;
  activeTab: '原価明細' | '原価計算' | '備考・補足';
  isDirty: boolean;
  
  // アクション
  setProjectInfo: (info: ProjectInfo) => void;
  setTableData: (data: EstimateTableRow[]) => void;
  addTableRow: () => void;
  removeTableRow: (id: string) => void;
  updateTableRow: (id: string, data: Partial<EstimateTableRow>) => void;
  setCostCalculation: (calc: CostCalculation) => void;
  setRemarksData: (data: RemarksData) => void;
  setApprovalInfo: (info: ApprovalInfo) => void;
  setActiveTab: (tab: '原価明細' | '原価計算' | '備考・補足') => void;
  recalculateAll: () => void;
  reset: () => void;
  save: () => Promise<void>;
  load: (id: string) => Promise<void>;
}

const initialProjectInfo: ProjectInfo = {
  estimateNumber: '',
  customer: '',
  deliveryDestination: '',
  equipmentName: '',
  productionQuantity: 0,
  productionUnit: '台',
  deliveryDate: new Date(),
  model: '',
  equipmentShape: '',
  weight: 0
};

const initialCostCalculation: CostCalculation = {
  materialCost: 0,
  processingCost: 0,
  paintingCost: 0,
  externalInspectionCost: 0,
  transportationCost: 0,
  factoryInspectionCost: 0,
  designCost: 0,
  directCost: 0,
  manufacturingCost: 0,
  totalCost: 0,
  paintingArea: 0
};

export const useEstimateStore = create<EstimateStore>()(
  devtools(
    (set, get) => ({
      // 初期状態
      projectInfo: initialProjectInfo,
      tableData: [],
      costCalculation: initialCostCalculation,
      remarksData: {
        remarks: ['', '', ''],
        materialCostNotes: ['', ''],
        internalProcessingNotes: ['', ''],
        externalProcessingNotes: ['', '']
      },
      approvalInfo: {
        assessor: '',
        assessmentDate: new Date(),
        approver: '',
        approvalDate: new Date(),
        finalApprover: '',
        seal1: '',
        seal2: '',
        seal3: '',
        seal4: '',
        personInCharge: ''
      },
      activeTab: '原価明細',
      isDirty: false,
      
      // アクション実装
      setProjectInfo: (info) => {
        set({ projectInfo: info, isDirty: true });
      },
      
      setTableData: (data) => {
        set({ tableData: data, isDirty: true });
        // 自動再計算
        get().recalculateAll();
      },
      
      addTableRow: () => {
        const newRow: EstimateTableRow = {
          id: crypto.randomUUID(),
          modelNumber: '',
          name: '',
          partType: '',
          material: '',
          dimensions: { partType: '' },
          quantity: 1,
          weight: 0,
          unitPrice: 0,
          price: 0,
          isAuto: false,
          isAutoInput: false,
          isTemplateDiff: false
        };
        set((state) => ({
          tableData: [...state.tableData, newRow],
          isDirty: true
        }));
      },
      
      removeTableRow: (id) => {
        set((state) => ({
          tableData: state.tableData.filter(row => row.id !== id),
          isDirty: true
        }));
        get().recalculateAll();
      },
      
      updateTableRow: (id, data) => {
        set((state) => ({
          tableData: state.tableData.map(row =>
            row.id === id ? { ...row, ...data } : row
          ),
          isDirty: true
        }));
        get().recalculateAll();
      },
      
      setCostCalculation: (calc) => {
        set({ costCalculation: calc, isDirty: true });
        get().recalculateAll();
      },
      
      setRemarksData: (data) => {
        set({ remarksData: data, isDirty: true });
      },
      
      setApprovalInfo: (info) => {
        set({ approvalInfo: info, isDirty: true });
      },
      
      setActiveTab: (tab) => {
        set({ activeTab: tab });
      },
      
      recalculateAll: () => {
        const { tableData, costCalculation } = get();
        
        // 材料費計算
        const materialCost = calculateMaterialCost(tableData);
        
        // 加工費計算
        const processingCost = calculateProcessingCost(tableData);
        
        // 塗装面積計算
        const paintingArea = calculatePaintingArea(tableData);
        
        // 塗装費計算
        const paintingCost = calculatePaintingCost(paintingArea);
        
        // 原価サマリー計算
        const totalCost =
          materialCost +
          processingCost +
          paintingCost +
          costCalculation.externalInspectionCost +
          costCalculation.transportationCost +
          costCalculation.factoryInspectionCost +
          costCalculation.designCost;
        
        const directCost = totalCost * 0.7;
        const manufacturingCost = totalCost * 0.9;
        
        set({
          costCalculation: {
            ...costCalculation,
            materialCost,
            processingCost,
            paintingCost,
            paintingArea,
            directCost,
            manufacturingCost,
            totalCost
          }
        });
      },
      
      reset: () => {
        set({
          projectInfo: initialProjectInfo,
          tableData: [],
          costCalculation: initialCostCalculation,
          remarksData: {
            remarks: ['', '', ''],
            materialCostNotes: ['', ''],
            internalProcessingNotes: ['', ''],
            externalProcessingNotes: ['', '']
          },
          approvalInfo: {
            assessor: '',
            assessmentDate: new Date(),
            approver: '',
            approvalDate: new Date(),
            finalApprover: '',
            seal1: '',
            seal2: '',
            seal3: '',
            seal4: '',
            personInCharge: ''
          },
          activeTab: '原価明細',
          isDirty: false
        });
      },
      
      save: async () => {
        const state = get();
        const estimate = {
          id: crypto.randomUUID(),
          ...state,
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        // ローカルストレージに保存
        await saveEstimate(estimate);
        
        set({ isDirty: false });
      },
      
      load: async (id: string) => {
        const estimate = await loadEstimate(id);
        if (estimate) {
          set({
            projectInfo: estimate.projectInfo,
            tableData: estimate.tableData,
            costCalculation: estimate.costCalculation,
            remarksData: estimate.remarksData,
            approvalInfo: estimate.approvalInfo,
            isDirty: false
          });
          get().recalculateAll();
        }
      }
    }),
    { name: 'EstimateStore' }
  )
);
```

---

## 3. ユーティリティ関数詳細設計

### 3.1 計算ロジック

#### 3.1.1 材料費計算

**ファイル**: `lib/calculation/materialCost.ts`

```typescript
import type { EstimateTableRow } from '@/types/estimate';

/**
 * 材料費を計算する
 * @param tableData テーブルデータ
 * @returns 材料費（円）
 */
export function calculateMaterialCost(tableData: EstimateTableRow[]): number {
  return tableData.reduce((sum, row) => {
    return sum + (row.price || 0);
  }, 0);
}
```

---

#### 3.1.2 加工費計算

**ファイル**: `lib/calculation/processingCost.ts`

```typescript
import type { EstimateTableRow } from '@/types/estimate';

/**
 * 加工費を計算する
 * @param tableData テーブルデータ
 * @returns 加工費（円）
 */
export function calculateProcessingCost(tableData: EstimateTableRow[]): number {
  // 総重量を計算
  const totalWeight = tableData.reduce((sum, row) => {
    return sum + (row.weight || 0);
  }, 0);
  
  // 部品種類数を計算
  const partTypeSet = new Set(
    tableData
      .filter(row => row.partType)
      .map(row => row.partType)
  );
  const partTypeCount = partTypeSet.size;
  
  // 計算式: 総重量(kg) × 1000円 + 部品種類数 × 5000円
  return totalWeight * 1000 + partTypeCount * 5000;
}
```

---

#### 3.1.3 塗装費計算

**ファイル**: `lib/calculation/paintingCost.ts`

```typescript
/**
 * 塗装費を計算する
 * @param paintingArea 塗装面積（m²）
 * @returns 塗装費（円）
 */
export function calculatePaintingCost(paintingArea: number): number {
  // 計算式: 塗装面積(m²) × 5000円
  return paintingArea * 5000;
}

/**
 * 塗装面積を計算する
 * @param tableData テーブルデータ
 * @returns 塗装面積（m²）
 */
export function calculatePaintingArea(tableData: EstimateTableRow[]): number {
  return tableData.reduce((sum, row) => {
    if (!row.dimensions || row.partType !== '板金') {
      return sum;
    }
    
    const { length, width, height } = row.dimensions;
    
    // 板金の場合、表面積を計算
    if (length && width && height) {
      // 6面の表面積を計算（mm² → m²）
      const area = 2 * (
        (length * width) +
        (width * height) +
        (height * length)
      ) / 1000000;
      return sum + area * row.quantity;
    }
    
    return sum;
  }, 0);
}
```

---

#### 3.1.4 重量計算

**ファイル**: `lib/calculation/weight.ts`

```typescript
import type { DimensionData } from '@/types/estimate';

// 材質別の密度（kg/m³）
const MATERIAL_DENSITY: Record<string, number> = {
  'SUS304': 7930,
  'SUS316': 8000,
  '炭素鋼': 7850,
  'アルミ': 2700
};

/**
 * 重量を計算する
 * @param dimensions 寸法データ
 * @param material 材質
 * @param partType Part Type
 * @returns 重量（kg）
 */
export function calculateWeight(
  dimensions: DimensionData,
  material: string,
  partType: string
): number {
  const density = MATERIAL_DENSITY[material] || 7850; // デフォルト: 炭素鋼
  
  switch (partType) {
    case '板金':
      if (dimensions.length && dimensions.width && dimensions.thickness) {
        // 体積 = 長さ × 幅 × 厚さ（mm³ → m³）
        const volume = (dimensions.length * dimensions.width * dimensions.thickness) / 1000000000;
        return volume * density;
      }
      break;
    
    case '円筒':
      if (dimensions.diameter && dimensions.height) {
        // 体積 = π × (直径/2)² × 高さ（mm³ → m³）
        const radius = dimensions.diameter / 2;
        const volume = Math.PI * radius * radius * dimensions.height / 1000000000;
        return volume * density;
      }
      break;
    
    default:
      // その他のPart Typeは0を返す（手動入力）
      return 0;
  }
  
  return 0;
}
```

---

### 3.2 ファイル処理

#### 3.2.1 Excel解析

**ファイル**: `lib/file/excelParser.ts`

```typescript
import ExcelJS from 'exceljs';
import type { EstimateTableRow } from '@/types/estimate';

interface ParseOptions {
  mode: '個別解析' | '2ファイル統合' | '3ファイル統合' | '2ファイル+価格参考';
  priceReference?: File;
}

/**
 * Excelファイルを解析する
 * @param file Excelファイル
 * @param options 解析オプション
 * @returns テーブル行データ
 */
export async function parseExcelFile(
  file: File,
  options: ParseOptions
): Promise<EstimateTableRow[]> {
  const workbook = new ExcelJS.Workbook();
  const buffer = await file.arrayBuffer();
  await workbook.xlsx.load(buffer);
  
  const rows: EstimateTableRow[] = [];
  
  // 最初のシートを読み込む
  const worksheet = workbook.worksheets[0];
  
  // ヘッダー行をスキップ（1行目）
  for (let i = 2; i <= worksheet.rowCount; i++) {
    const row = worksheet.getRow(i);
    
    // 空行はスキップ
    if (!row.getCell(1).value) {
      continue;
    }
    
    const tableRow: EstimateTableRow = {
      id: crypto.randomUUID(),
      modelNumber: String(row.getCell(1).value || ''),
      name: String(row.getCell(2).value || ''),
      partType: String(row.getCell(3).value || ''),
      material: String(row.getCell(4).value || ''),
      dimensions: {
        partType: String(row.getCell(3).value || ''),
        // 寸法データの解析（列5-8など）
      },
      quantity: Number(row.getCell(6).value) || 1,
      weight: Number(row.getCell(7).value) || 0,
      unitPrice: Number(row.getCell(8).value) || 0,
      price: Number(row.getCell(9).value) || 0,
      isAuto: Boolean(row.getCell(10).value),
      isAutoInput: true, // ファイルから読み込んだデータ
      isTemplateDiff: false
    };
    
    rows.push(tableRow);
  }
  
  return rows;
}
```

---

#### 3.2.2 PDF解析

**ファイル**: `lib/file/pdfParser.ts`

```typescript
import { PDFDocument } from 'pdf-lib';
import type { EstimateTableRow } from '@/types/estimate';

/**
 * PDFファイルを解析する
 * @param file PDFファイル
 * @param options 解析オプション
 * @returns テーブル行データ
 */
export async function parsePdfFile(
  file: File,
  options: ParseOptions
): Promise<EstimateTableRow[]> {
  const arrayBuffer = await file.arrayBuffer();
  const pdfDoc = await PDFDocument.load(arrayBuffer);
  
  const pages = pdfDoc.getPages();
  const rows: EstimateTableRow[] = [];
  
  // PDFからテキストを抽出（簡易実装）
  // 実際の実装では、PDF.js等を使用してテキスト抽出を行う
  
  // テキスト解析ロジック
  // 表形式のデータを抽出してEstimateTableRowに変換
  
  return rows;
}
```

---

### 3.3 出力処理

#### 3.3.1 PDF出力

**ファイル**: `lib/export/pdfExporter.ts`

```typescript
import jsPDF from 'jspdf';
import type { ExportData } from '@/types/estimate';

/**
 * PDF形式で出力する
 * @param data 出力データ
 */
export async function exportToPdf(data: ExportData): Promise<void> {
  const doc = new jsPDF();
  
  let y = 20;
  
  // ヘッダー
  doc.setFontSize(18);
  doc.text('見積書', 105, y, { align: 'center' });
  y += 10;
  
  // 見積番号
  doc.setFontSize(12);
  doc.text(`見積番号: ${data.projectInfo.estimateNumber}`, 20, y);
  y += 10;
  
  // 基本情報
  doc.setFontSize(14);
  doc.text('基本情報', 20, y);
  y += 10;
  
  doc.setFontSize(10);
  doc.text(`客先: ${data.projectInfo.customer}`, 20, y);
  y += 7;
  doc.text(`向先: ${data.projectInfo.deliveryDestination}`, 20, y);
  y += 7;
  // その他の基本情報
  
  // 原価明細テーブル
  y += 10;
  doc.setFontSize(14);
  doc.text('原価明細', 20, y);
  y += 10;
  
  // テーブルヘッダー
  doc.setFontSize(10);
  doc.text('型式', 20, y);
  doc.text('名称', 50, y);
  doc.text('数量', 100, y);
  doc.text('単価', 120, y);
  doc.text('価格', 150, y);
  y += 7;
  
  // テーブルデータ
  data.tableData.forEach(row => {
    if (y > 250) {
      doc.addPage();
      y = 20;
    }
    
    doc.text(row.modelNumber, 20, y);
    doc.text(row.name, 50, y);
    doc.text(String(row.quantity), 100, y);
    doc.text(String(row.unitPrice), 120, y);
    doc.text(String(row.price), 150, y);
    y += 7;
  });
  
  // 原価計算結果
  y += 10;
  doc.setFontSize(14);
  doc.text('原価計算', 20, y);
  y += 10;
  
  doc.setFontSize(10);
  doc.text(`材料費: ${data.costCalculation.materialCost.toLocaleString('ja-JP')}円`, 20, y);
  y += 7;
  doc.text(`加工費: ${data.costCalculation.processingCost.toLocaleString('ja-JP')}円`, 20, y);
  y += 7;
  doc.text(`総原価: ${data.costCalculation.totalCost.toLocaleString('ja-JP')}円`, 20, y);
  
  // ファイル名生成
  const fileName = `見積書_${data.projectInfo.estimateNumber}_${formatDate(new Date())}.pdf`;
  
  // ダウンロード
  doc.save(fileName);
}
```

---

#### 3.3.2 Excel出力

**ファイル**: `lib/export/excelExporter.ts`

```typescript
import ExcelJS from 'exceljs';
import type { ExportData } from '@/types/estimate';

/**
 * Excel形式で出力する
 * @param data 出力データ
 */
export async function exportToExcel(data: ExportData): Promise<void> {
  const workbook = new ExcelJS.Workbook();
  
  // 基本情報シート
  const infoSheet = workbook.addWorksheet('基本情報');
  infoSheet.addRow(['見積番号', data.projectInfo.estimateNumber]);
  infoSheet.addRow(['客先', data.projectInfo.customer]);
  // その他の基本情報
  
  // 原価明細シート
  const tableSheet = workbook.addWorksheet('原価明細');
  tableSheet.addRow(['型式', '名称', 'Part Type', '材質', '数量', '重量', '単価', '価格']);
  
  data.tableData.forEach(row => {
    tableSheet.addRow([
      row.modelNumber,
      row.name,
      row.partType,
      row.material,
      row.quantity,
      row.weight,
      row.unitPrice,
      row.price
    ]);
  });
  
  // 原価計算シート
  const costSheet = workbook.addWorksheet('原価計算');
  costSheet.addRow(['項目', '金額']);
  costSheet.addRow(['材料費', data.costCalculation.materialCost]);
  costSheet.addRow(['加工費', data.costCalculation.processingCost]);
  costSheet.addRow(['総原価', data.costCalculation.totalCost]);
  
  // ファイル名生成
  const fileName = `見積書_${data.projectInfo.estimateNumber}_${formatDate(new Date())}.xlsx`;
  
  // ダウンロード
  const buffer = await workbook.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const url = window.URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = fileName;
  link.click();
  window.URL.revokeObjectURL(url);
}
```

---

## 4. エラーハンドリング詳細設計

### 4.1 エラークラス定義

**ファイル**: `lib/errors/AppError.ts`

```typescript
export enum ErrorType {
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  FILE_ERROR = 'FILE_ERROR',
  PARSE_ERROR = 'PARSE_ERROR',
  CALCULATION_ERROR = 'CALCULATION_ERROR',
  STORAGE_ERROR = 'STORAGE_ERROR',
  EXPORT_ERROR = 'EXPORT_ERROR'
}

export class AppError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}
```

### 4.2 エラーハンドリングユーティリティ

**ファイル**: `lib/errors/errorHandler.ts`

```typescript
import { AppError, ErrorType } from './AppError';

export function handleError(error: unknown): void {
  if (error instanceof AppError) {
    switch (error.type) {
      case ErrorType.VALIDATION_ERROR:
        showToast('error', error.message);
        break;
      case ErrorType.FILE_ERROR:
        showToast('error', `ファイルエラー: ${error.message}`);
        break;
      case ErrorType.PARSE_ERROR:
        showToast('error', `解析エラー: ${error.message}`);
        break;
      default:
        showToast('error', error.message);
    }
  } else {
    showToast('error', '予期しないエラーが発生しました');
    console.error(error);
  }
}

function showToast(type: 'success' | 'error' | 'info', message: string): void {
  // トースト通知の実装
}
```

---

## 5. パフォーマンス最適化

### 5.1 メモ化

```typescript
// 計算結果のメモ化
import { useMemo } from 'react';

const materialCost = useMemo(() => {
  return calculateMaterialCost(tableData);
}, [tableData]);
```

### 5.2 仮想スクロール

```typescript
// 大量データのテーブル表示時に仮想スクロールを使用
import { useVirtualizer } from '@tanstack/react-virtual';

const virtualizer = useVirtualizer({
  count: tableData.length,
  getScrollElement: () => parentRef.current,
  estimateSize: () => 50,
  overscan: 5
});
```

### 5.3 デバウンス

```typescript
// 入力処理のデバウンス
import { useDebouncedCallback } from 'use-debounce';

const debouncedUpdate = useDebouncedCallback(
  (value: string) => {
    updateTableRow(id, { name: value });
  },
  300
);
```

---

## 6. テストケース設計

### 6.1 単体テスト

**ファイル**: `tests/unit/calculation/materialCost.test.ts`

```typescript
import { calculateMaterialCost } from '@/lib/calculation/materialCost';
import type { EstimateTableRow } from '@/types/estimate';

describe('calculateMaterialCost', () => {
  it('should calculate total material cost', () => {
    const tableData: EstimateTableRow[] = [
      { price: 1000 } as EstimateTableRow,
      { price: 2000 } as EstimateTableRow,
      { price: 3000 } as EstimateTableRow
    ];
    
    expect(calculateMaterialCost(tableData)).toBe(6000);
  });
  
  it('should return 0 for empty array', () => {
    expect(calculateMaterialCost([])).toBe(0);
  });
  
  it('should handle null prices', () => {
    const tableData: EstimateTableRow[] = [
      { price: 1000 } as EstimateTableRow,
      { price: null as any } as EstimateTableRow
    ];
    
    expect(calculateMaterialCost(tableData)).toBe(1000);
  });
});
```

---

## 7. まとめ

本詳細設計書では、見積書デモアプリの各コンポーネント、関数、処理の詳細な実装仕様を定義しました。この設計書に基づいて実装を進めることで、一貫性のある高品質なアプリケーションを開発できます。

